<title> The magic behind a simple kubectl command!</title>
<center><b>The magic behind a simple kubectl command! </b> </center>
<br/><hr>
<br/>
Hey folks, as promised this is the first article in the k8s code's collection.<br/>
We gonna talk about <b>kubectl</b> its code implementation and how it works during the runtime.<br/>
First, we need to clone the k8s repository, of course am assuming that you have go installed and all the variables related to it like (GOPATH and GOROOT) are alraedy set.<br/>
<code> go get -d k8s.io/kubernetes </code><br/>
Once this done, you will see the structure of k8s's repository<br/>
<pre><code>
Godeps/ <br/>
api/ <br/>
build/ <br/>
cluster/ <br/>
cmd/ <br/>
docs/ <br/>
hack/ <br/>
logo/ <br/>
pkg/ <br/>
plugin/ <br/>
staging/ <br/>
test/ <br/>
third_party/ <br/>
translations/ <br/>
vendor/ <br/>
</code></pre><br/>
For now, while we are talking about <i>kubectl</i>, we will be interested by <b>pkg/</b> folder. There we can find some sub-directories and files. <br/>
<pre><code>
pi   auth   capabilities  cloudprovider  credentialprovider  fieldpath  kubeapiserver  kubelet   master  printers  proxy  registry  scheduler  securitycontext  ssh   version  watch <br/>
apis  BUILD  client        controller     features            generated  kubectl        kubemark  OWNERS  probe     quota  routes    security   serviceaccount   util  volume   windows<br/>
</code></pre>
<br/>
As you can see, we have the folder <b>kubectl</b>. The folder in there which is <b>cmd</b> is the entry point for all kubectl commands.<br/>
Every kubectl command has an initial entry point, it can be directly a file or if the command have several usage which will contain many go files, it will be under a folder.<br/>
Let's pick an example, you have your k8s cluster up and running and you want to create a new namespace. In this case, your command will be <code> kubectl create namespace </code><br/>
Sounds easy right? Okay :) let's trace that kubectl create command and see where the implementation of the code. <br/> 
There is always more than one way to do that. You can dump or display information from the kubectl binary itself using objdump for example<br/>
or just go and read the documentation and have a quick look on the sub-directories in <b>pkg/kubectl/cmd/</b> and you will notice that there is a folder with <b>create</b> as a name.<br/>
Let's open the go file <i>pkg/kubectl/cmd/create/create.go</i> which is associated to the kubectl create command including every possible argument.<br/>
<pre><code>
 81 func NewCreateOptions(ioStreams genericclioptions.IOStreams) *CreateOptions { <br/>
 82         return &CreateOptions{ <br/>
 83                 PrintFlags:  genericclioptions.NewPrintFlags("created").WithTypeSetter(scheme.Scheme),<br/>
 84                 RecordFlags: genericclioptions.NewRecordFlags(),<br/>
 85<br/>
 86                 Recorder: genericclioptions.NoopRecorder{},<br/>
 87<br/>
 88                 IOStreams: ioStreams,<br/>
 89         }<br/>
 90 }<br/>
 91<br/>
 <b>92</b> func NewCmdCreate(f cmdutil.Factory, ioStreams genericclioptions.IOStreams) *cobra.Command {<br/>
 93         o := NewCreateOptions(ioStreams)<br/>
 94<br/>
 95         cmd := &cobra.Command{<br/>
 96                 Use: "create -f FILENAME",<br/>
 97                 DisableFlagsInUseLine: true,<br/>
 98                 Short:   i18n.T("Create a resource from a file or from stdin."),<br/>
 99                 Long:    createLong,<br/>
100                 Example: createExample,<br/>
101                 Run: func(cmd *cobra.Command, args []string) {<br/>
102                         if cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames) {<br/>
103                                 defaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)<br/>
104                                 defaultRunFunc(cmd, args)<br/>
105                                 return<br/>
106                         }<br/>
107                         cmdutil.CheckErr(o.Complete(f, cmd))<br/>
108                         cmdutil.CheckErr(o.ValidateArgs(cmd, args))<br/>
109                         cmdutil.CheckErr(o.RunCreate(f, cmd))<br/>
110                 },<br/>
<b>111</b>         }<br/>
112<br/>
113         // bind flag structs<br/>
114         o.RecordFlags.AddFlags(cmd)<br/>
115<br/>
116         usage := "to use to create the resource"<br/>
117         cmdutil.AddFilenameOptionFlags(cmd, &o.FilenameOptions, usage)<br/>
118         cmd.MarkFlagRequired("filename")<br/>
119         cmdutil.AddValidateFlags(cmd)<br/>
120         cmd.Flags().BoolVar(&o.EditBeforeCreate, "edit", o.EditBeforeCreate, "Edit the API resource before creating")<br/>
121         cmd.Flags().Bool("windows-line-endings", runtime.GOOS == "windows",<br/>
122                 "Only relevant if --edit=true. Defaults to the line ending native to your platform.")<br/>
123         cmdutil.AddApplyAnnotationFlags(cmd)<br/>
124         cmdutil.AddDryRunFlag(cmd)<br/>
125         cmd.Flags().StringVarP(&o.Selector, "selector", "l", o.Selector, "Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2)")<br>
126         cmd.Flags().StringVar(&o.Raw, "raw", o.Raw, "Raw URI to POST to the server.  Uses the transport specified by the kubeconfig file.")<br/>
127<br/>
128         o.PrintFlags.AddFlags(cmd)<br/>
129<br/>
130         // create subcommands<br/>
131         cmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))<br/>
132         cmd.AddCommand(NewCmdCreateQuota(f, ioStreams))<br/>
133         cmd.AddCommand(NewCmdCreateSecret(f, ioStreams))<br/>
134         cmd.AddCommand(NewCmdCreateConfigMap(f, ioStreams))<br/>
135         cmd.AddCommand(NewCmdCreateServiceAccount(f, ioStreams))<br/>
136         cmd.AddCommand(NewCmdCreateService(f, ioStreams))<br/>
137         cmd.AddCommand(NewCmdCreateDeployment(f, ioStreams))<br/>
138         cmd.AddCommand(NewCmdCreateClusterRole(f, ioStreams))<br/>
139         cmd.AddCommand(NewCmdCreateClusterRoleBinding(f, ioStreams))<br/>
140         cmd.AddCommand(NewCmdCreateRole(f, ioStreams))<br/>
141         cmd.AddCommand(NewCmdCreateRoleBinding(f, ioStreams))<br/>
142         cmd.AddCommand(NewCmdCreatePodDisruptionBudget(f, ioStreams))<br/>
</code></pre>
<br/>
I took this piece of code from create.go file to demonstrate the implementation of the command <b>kubectl create -f file</b> at the runtime. <br/> 
The function associated to this starts from the line <b>92</b> and ends at the line <b>111</b><br/>
You can notice there that kubernetes commands are implemented using the <a href="https://github.com/spf13/cobra">Cobra command framework</a>. Cobra provides a lot of great features for building CLI. <br/>
As you can see here<br/><br/>
<pre>   <code>     
         cmd := &cobra.Command{<br/>
                 Use: "create -f FILENAME",<br/>
                 DisableFlagsInUseLine: true,<br/>
                 Short:   i18n.T("Create a resource from a file or from stdin."),<br/>
                 Long:    createLong,<br/>
                 Example: createExample,<br/>
                 Run: func(cmd *cobra.Command, args []string) {<br/>
                         if cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames) {<br/>
                                 defaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)<br/>
                                 defaultRunFunc(cmd, args)<br/>
                                 return<br/>
                         }<br/>
                         cmdutil.CheckErr(o.Complete(f, cmd))<br/>
                         cmdutil.CheckErr(o.ValidateArgs(cmd, args))<br/>
                         cmdutil.CheckErr(o.RunCreate(f, cmd))<br/>
                 },<br/>
         }<br/>
</code></pre><br/>
Cobra makes it very easy to locate which file implements each command line option. It gives also the ability to put the command <b>usage</b> alongside a brief description of what the command can do.<br/>
While this is implemented in every piece of kuberenetes. So, you can walk through all kubectl commands and you can read their descriptions which will make you jump to the piece of code you need.<br/>
As shown in lines 96-101 in the snippet of code, the strings Use, Short, Long, and Example all hold information describing the command and Run points to a function that actually runs the command.<br/>
The RunCreate function invoked on line 109 is where the bulk of the kubectl create command is implemented. The implementation of this function can be found in the same file <b>create.go</b><br/>
<pre>
<code>
205 func (o *CreateOptions) RunCreate(f cmdutil.Factory, cmd *cobra.Command) error {
206         // raw only makes sense for a single file resource multiple objects aren't likely to do what you want.
207         // the validator enforces this, so
208         if len(o.Raw) > 0 {
209                 return o.raw(f)
210         }
211
212         if o.EditBeforeCreate {
213                 return RunEditOnCreate(f, o.PrintFlags, o.RecordFlags, o.IOStreams, cmd, &o.FilenameOptions)
214         }
215         schema, err := f.Validator(cmdutil.GetFlagBool(cmd, "validate"))
216         if err != nil {
217                 return err
218         }
219
220         cmdNamespace, enforceNamespace, err := f.ToRawKubeConfigLoader().Namespace()
221         if err != nil {
222                 return err
223         }
224
225         r := f.NewBuilder().
226                 Unstructured().
227                 Schema(schema).
228                 ContinueOnError().
229                 NamespaceParam(cmdNamespace).DefaultNamespace().
230                 FilenameParam(enforceNamespace, &o.FilenameOptions).
231                 LabelSelectorParam(o.Selector).
232                 Flatten().
233                 Do()
234         err = r.Err()
235         if err != nil {
236                 return err
237         }
238
239         count := 0
240         err = r.Visit(func(info *resource.Info, err error) error {
241                 if err != nil {
242                         return err
243                 }
244                 if err := kubectl.CreateOrUpdateAnnotation(cmdutil.GetFlagBool(cmd, cmdutil.ApplyAnnotationsFlag), info.Object, cmdutil.InternalVersionJSONEncoder()); err != nil {
245                         return cmdutil.AddSourceToErr("creating", info.Source, err)
246                 }
247
248                 if err := o.Recorder.Record(info.Object); err != nil {
249                         glog.V(4).Infof("error recording current command: %v", err)
250                 }
251
252                 if !o.DryRun {
253                         if err := createAndRefresh(info); err != nil {
254                                 return cmdutil.AddSourceToErr("creating", info.Source, err)
255                         }
256                 }
257
258                 count++
259
260                 return o.PrintObj(info.Object)
261         })
262         if err != nil {
263                 return err
264         }
265         if count == 0 {
266                 return fmt.Errorf("no objects passed to create")
267         }
268         return nil
269 }
</code>
</pre>
<br/>
<br/>
<br/>
<br/>
<br/>

Cheers <b>o/</b>

                                 
